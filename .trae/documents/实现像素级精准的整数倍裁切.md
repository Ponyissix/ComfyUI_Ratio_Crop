# 像素级精准裁切修复方案

用户要求“像素级完全精准”的裁切比例。仅仅在浮点数计算上做“近似匹配”是不够的，因为整数像素的离散性会导致无法完美匹配所有浮点比例（例如 `563x1000` 并非精确的 `9:16`）。

要实现数学上的**绝对精准**，裁切后的宽和高必须分别是比例分子和分母的**整数倍**（对于最简分数）。
例如：要实现精确的 `9:16`，宽度必须是 9 的倍数，高度必须是 16 的倍数。

## 核心变更：引入“整数倍量化” (Integer Quantization)

我将重写 `nodes.py` 中的裁切尺寸计算逻辑，引入严格的整数约束：

1.  **比例解析**：
    将比例字符串解析为整数元组 `(rw, rh)`。
    -   `9:16` -> `(9, 16)`
    -   `4:3` -> `(4, 3)`
    -   `21:9` -> `(7, 3)` (最简分数)

2.  **最大公约数倍率计算 (GCD Factor)**：
    基于当前可用的 Bounding Box `(bw, bh)`，计算最大的整数倍率 `k`。
    -   `k_w = bw // rw` (宽度能容纳多少个单位)
    -   `k_h = bh // rh` (高度能容纳多少个单位)
    -   `k = min(k_w, k_h)` (取较小值，确保能放入框内)

3.  **最终尺寸计算**：
    -   `final_w = k * rw`
    -   `final_h = k * rh`
    这样计算出的 `final_w / final_h` 恒等于 `rw / rh`，误差为 **0**。

4.  **居中修正**：
    将计算出的完美尺寸 `final_w, final_h` 在原裁切中心进行居中。

## 示例验证
-   **场景**：图片高 1536，Mask 宽 980，目标 9:16。
-   **计算**：
    -   `rw=9, rh=16`
    -   `bw=980, bh=1536`
    -   `k_w = 980 // 9 = 108`
    -   `k_h = 1536 // 16 = 96`
    -   `k = min(108, 96) = 96`
    -   `final_w = 96 * 9 = 864`
    -   `final_h = 96 * 16 = 1536`
-   **结果**：`864x1536`。`864/1536 = 0.5625` (精确 9:16)。

这将从根本上解决“对不上”的问题，满足用户对像素级精度的要求。
