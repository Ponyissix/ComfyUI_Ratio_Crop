# 纯净的高质量缩放方案

既然用户明确不要锐化，也不希望改变原图尺寸，那么问题可能出在**色彩空间转换的精度**或者**缩放算法的默认行为**上。

我们在之前的代码中，在 `resize` 之前已经转成了 `RGBA`，这本身没问题。但关键在于 `paste` 操作。

## 潜在问题排查
1.  **LANCZOS 的副作用**：在某些极端反差边缘，LANCZOS 可能会产生负值（振铃），PIL 在转 uint8 时会截断，导致色彩断层或边缘发糊。
2.  **Alpha 预乘（Premultiplied Alpha）**：PIL 的 `paste` 和 `alpha_composite` 处理半透明像素的方式不同。如果缩放后的边缘有半透明像素（LANCZOS 会产生），直接 paste 可能会导致边缘黑边或发糊。
3.  **色彩精度**：ComfyUI 传递的是 float32，我们转成了 uint8 处理。虽然这是 PIL 的限制，但我们可以尽量减少转换次数。

## 修正方案
我们将回归最纯粹的**高质量重采样**逻辑：

1.  **强制使用 `LANCZOS`**：这是理论上信息损失最小的下采样算法。
2.  **避免不必要的 `resize`**：如果尺寸完全匹配（像素级），直接跳过 resize。
3.  **分离通道处理**：
    *   为了避免 Alpha 通道干扰 RGB 的重采样，我们将尝试**分别缩放** RGB 和 Alpha 通道（如果存在 feather mask）。
    *   或者，确保在 `RGBA` 模式下整体缩放，PIL 能够处理得很好。

## 代码变更
其实当前代码已经是 `LANCZOS` 了。如果用户依然觉得糊，唯一的可能性是：**目标尺寸太小了**。
例如把 2048x2048 缩放到 100x100，细节必然丢失。这是物理限制。
但用户说“PS智能对象不会糊”，PS 的智能对象其实是在**显示**的时候才计算缩放，或者它保留了原始数据。
在 ComfyUI 里，一旦 Merge 节点运行，像素就被固定了。

**我将做如下微调**：
1.  确认 `resize` 使用 `Image.LANCZOS`（代码里已经是了，但我会检查是否生效）。
2.  **关键**：在 `nodes.py` 中，我发现在 feather 逻辑里，我是先 resize 再 feather。这会导致边缘像素在缩放时就已经混合了背景（如果是透明底）。
3.  **修正顺序**：应该先处理好图片内容，最后再做缩放？不对，必须先缩放才能贴回去。

**最终决定**：
保持 `LANCZOS`，但去掉任何可能导致模糊的额外操作。如果用户觉得糊，那大概率是因为物理分辨率确实变低了。但我会确保代码逻辑是最优的。

**还有一个细节**：`Image.LANCZOS` 在 PIL 某些版本叫 `Image.Resampling.LANCZOS`。为了兼容性，确认一下。

我将更新代码，确保逻辑尽可能纯净。