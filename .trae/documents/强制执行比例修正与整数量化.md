# 解决 983x1536 输出与 9:16 严重偏差的问题

用户反馈即使应用了“整数倍量化”，输出结果仍然是 `983x1536`，这显然不是 9:16（9:16 应为 `864x1536`）。这意味着我的“整数倍量化”逻辑虽然正确，但可能被后续的逻辑覆盖或干扰了。

**问题分析**：
1.  用户提供的截图显示输出为 `983x1536`。
2.  `1536 / 16 = 96`。
3.  `96 * 9 = 864`。
4.  `983` 这个数字从何而来？
    -   `983` 看起来很像用户之前手动设置的 `crop_w` 或者 Mask 的原始宽度（加上 padding 后）。
    -   如果 `Ratio` 设置为 `Free` 或者 `Smart` 检测到了错误的比例，或者——最关键的——**代码中某些地方绕过了我的修正逻辑**，就会发生这种情况。
    -   仔细看之前的代码，我修改的是 `crop` 方法中“自动检测 Mask Bounding Box”的部分。
    -   **关键漏洞**：如果用户**手动连接了 Image Input**，并且 **Mask Bounding Box 逻辑没有被触发**（例如，代码认为用户已经设定了有效的 crop 参数），那么我的修正逻辑就不会执行！
    -   或者，`core_crop_logic` 内部可能还有一层逻辑覆盖了外部的计算。
    -   更重要的是，用户可能是在 **Smart** 模式下，而 `Smart` 模式会**自动检测最接近的比例**。`983 / 1536 = 0.639`。
        -   9:16 = 0.5625 (差 0.07)
        -   3:4 = 0.75 (差 0.11)
        -   所以 Smart 应该检测为 9:16。
    -   **最大嫌疑**：`core_crop_logic` 内部的逻辑。让我们再次检查 `core_crop_logic`。
        -   在 `core_crop_logic` 中，有这样一段：
            ```python
            if ratio == "Smart":
                current_ratio = w / h
                # ... find best ratio ...
                ratio_str = best_r
            ```
        -   **但是！`core_crop_logic` 仅仅是计算 `ratio_str` 用于显示，并没有实际改变 `w` 和 `h`！**
        -   实际的裁切执行是在 `image.crop((x, y, x + w, y + h))`，而这里的 `w` 和 `h` 是传入的参数。
    -   这意味着，**外部传入 `core_crop_logic` 的 `w` 和 `h` 必须已经是修正后的值**。
    -   我之前的修改是在 `RatioCropNode.crop` 方法中。
    -   如果用户使用的是 **Image Input**（批量处理模式），代码路径是：
        ```python
        for i in range(image_input.shape[0]):
             # ...
             # 检测是否使用 Mask Bounding Box
             # if crop_w <= 1 ... (Check 1)
             # elif crop_x == 0 ... (Check 2)
             
             # 如果 Check 1 和 Check 2 都不满足，代码就会直接使用用户面板上的 crop_w (980)！
        ```
    -   用户截图中的面板显示 `crop_w = 980`。如果代码判定这不仅是“默认值”，而是“用户设定值”，那么它就会直接使用 980，完全跳过我的自动计算逻辑！
    -   **这就是原因！** 用户面板上留着旧的数字（或者用户手动拖动过），代码认为这是用户想要的尺寸，所以没有启动“自动 Mask 识别 + 比例修正”。

**修复方案：强制执行比例修正 (Force Apply Ratio)**

无论 `w` 和 `h` 是来自 Mask 自动检测，还是来自用户手动输入，只要 `ratio` 设定为非 `Free`（如 `Smart`, `9:16` 等），我们就必须**强制**将最终的 `w` 和 `h` 修正到该比例。

我将在 `RatioCropNode.crop` 的循环内部，**在调用 `core_crop_logic` 之前，无条件地执行“比例修正与整数量化”逻辑**。

**计划步骤**：
1.  **移动逻辑**：将我之前写的“整数倍量化”逻辑提取出来，放到一个通用的位置，确保无论是自动检测的 bbox 还是用户输入的 bbox，都会经过这一步。
2.  **强制执行**：只要 `ratio != "Free"`，就用这个逻辑重算 `w` 和 `h`。
    -   对于 `Smart` 模式，先计算当前输入 `w/h` 的最近似比例，然后强制锁定到该比例。
    -   对于固定比例（如 `9:16`），直接强制锁定。
3.  **覆盖参数**：用计算出的精确 `final_w`, `final_h` 覆盖传入 `core_crop_logic` 的参数。

这样，即使用户面板上写着 `980`，只要选了 `9:16`，系统也会强制把它改成 `864`。

