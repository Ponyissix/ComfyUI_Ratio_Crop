# 实现双蒙版输出：裁切蒙版与画笔蒙版

用户希望 `RatioCropNode` 能够输出两个独立的 Mask：
1.  **裁切图蒙版 (crop_mask)**: 对应最终绿色裁切框区域的矩形蒙版（目前已实现）。
2.  **画笔蒙版 (brush_mask)**: 用户在前端用红色画笔涂抹出的不规则形状蒙版。

## 挑战与解决方案

### 数据回传问题
目前的架构中，前端（JS）只向后端（Python）传递了 widgets 的值（如 x, y, w, h）。用户绘制的 `brush_mask` 是存在于浏览器内存中的 Canvas 数据，后端无法直接获取。

### 解决方案：Mask 上传机制
我们需要建立一个从前端 Canvas 到后端文件系统的上传通道。

1.  **前端 (js/crop_ui.js)**:
    *   在点击“确认裁切”时，将 `maskCanvas` 的内容导出为 Blob/File。
    *   使用 `api.uploadApi` 将这个临时的 Mask 图片上传到 ComfyUI 的 `input` 目录（或者临时目录）。
    *   文件名可以命名为 `clip_space_mask_{node_id}.png` 或类似，防止冲突。
    *   将上传后的文件名写入到一个隐藏的 Widget 中（例如名为 `brush_mask_image` 的隐藏文本框）。

2.  **后端 (nodes.py)**:
    *   修改 `INPUT_TYPES`，增加一个隐藏的 `brush_mask_image` 字段（STRING 类型），用于接收前端传来的文件名。
    *   在 `crop` 函数执行时，读取这个图片文件，将其转换为 `MASK` Tensor。
    *   修改 `RETURN_TYPES`，增加第二个 `MASK` 输出。

## 详细实施步骤

### 1. 修改 `nodes.py`
*   **输入**：增加 `brush_mask_path` (STRING, hidden=True)。
*   **输出**：将原来的 `mask` 改名为 `crop_mask`，并新增 `brush_mask`。
*   **逻辑**：
    *   `crop_mask` 依然通过 `x, y, w, h` 动态生成。
    *   `brush_mask` 则尝试读取 `brush_mask_path` 指定的图片。如果为空或文件不存在，则返回全黑蒙版。

### 2. 修改 `js/crop_ui.js`
*   在 `showCropEditor` 的 `confirmBtn.onclick` 事件中：
    *   调用 `maskCanvas.toBlob()`。
    *   构造 `FormData` 并调用 `/upload/image` 接口。
    *   上传成功后，获取文件名，填入隐藏的 widget。
*   **注意**：ComfyUI 的标准上传接口通常用于 LoadImage 节点。我们需要模拟这个行为。

## 替代方案（更轻量）
如果上传图片太慢或太复杂，我们可以把 Mask 数据压缩为 Base64 字符串存入 Widget？
*   ComfyUI 的 Widget 长度限制可能会截断 Base64（如果图片很大）。
*   因此，**上传文件**是最稳妥的方式。

## 执行计划
1.  修改 `nodes.py`：更新输入输出定义，添加 Mask 读取逻辑。
2.  修改 `js/crop_ui.js`：实现 Mask 图片的上传与文件名回填逻辑。

请确认执行。