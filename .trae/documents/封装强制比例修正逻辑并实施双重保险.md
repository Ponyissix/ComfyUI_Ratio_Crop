# 终极修复方案：双重强制修正与逻辑封装

虽然之前的修复在理论上是正确的，但用户反馈问题依旧，且出现了无法解释的尺寸（如 983）。这表明问题可能出在逻辑覆盖不全或 `core_crop_logic` 内部的边界检查再次破坏了比例。

为了彻底解决这个问题，我将采取**防御性编程**策略：
1.  **封装核心算法**：将“强制比例修正与整数量化”逻辑提取为独立的纯函数 `apply_ratio_logic`，确保在任何地方调用都能得到一致的数学结果。
2.  **双重保险**：
    -   **第一道防线（外部）**：在 `RatioCropNode.crop` 中，在决定最终裁切参数时调用该函数。
    -   **第二道防线（内部 - 关键）**：在 `core_crop_logic` 的**最开始**，再次调用该函数。这是所有裁切操作的必经之路，无论外部参数如何混乱，只要进了这个函数，就会被强制“格式化”为标准比例。
3.  **消除边界检查的副作用**：在 `core_crop_logic` 中，确保经过修正后的 `w, h` 不会被后续的 `if x + w > img_w` 简单粗暴地截断（因为我们的修正逻辑已经包含了更智能的 Clamp）。

## 核心算法逻辑 (apply_ratio_logic)
该函数将接收 `x, y, w, h, img_w, img_h, ratio`，并执行：
1.  **解析比例**：将 `Smart` 或 `9:16` 解析为整数元组 `(rw, rh)`。
2.  **计算最大倍率 k**：`k = min(img_w // rw, img_h // rh)`。
3.  **计算最佳倍率**：根据当前 `w, h` 覆盖率，选择最接近的整数倍率 `k`。
4.  **生成尺寸**：`final_w = k * rw`, `final_h = k * rh`。
5.  **居中与越界保护**：计算居中坐标，并确保完全在图片范围内。

通过这种方式，我们可以保证输出绝对是 `rw` 和 `rh` 的整数倍，不存在任何“差几个像素”的可能性。
